class chartime {
	double[] secs;
	string name;
	// Constructors
	chartime(string who, double[] values) {
		this.setup(who, values);
	}
	chartime(string who, double value) {
		this.setup(who, {value});
	}
	private void setup(string who, double[] values) {
		this.secs.resize(0);
		this.name = who;
		this.secs = values;
	}
	double get_sec() property { return (this.secs.length() > 0 ? this.secs[0] : 0); }
	int opIndex(uint n) const {
		return this.secs[n];
	}
	uint length() const {
		return this.secs.length();
	}
	int opCmp(const chartime@ other) const {
		if (this.length() > other.length()) return 1;
		else if (this.length() < other.length()) return -1;
		for (uint i = 0; i < this.length(); i++) {
			double a = this[i];
			double b = other[i];
			if (a > b) return 1;
			else if (a < b) return -1;
		}
		return 0; // equal
	}
}
chartime@[] sort_chartime(chartime@[] chars, bool smallest_first = false) {
	if (chars.length() < 2) return chars;
	if (!smallest_first) {
		// Sort largest first (descending): a should precede b if a > b.
		// a.opCmp(b) returns 1 if a > b.
		chars.sort(function(a, b) {
			return a.opCmp(b) > 0; // true if a > b
		});
	} else {
		// Sort smallest first (ascending): a should precede b if a < b.
		// a.opCmp(b) returns -1 if a < b.
		chars.sort(function(a, b) {
			return a.opCmp(b) < 0; // true if a < b
		});
	}
	return chars;
}
