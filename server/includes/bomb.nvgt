#include "bgt_compat.nvgt"#include "bgt_compat.nvgt"censor_bomb@[] censor_bombs(0);
class censor_bomb {
	player@owner;
	int z;
	mapdata@map;
	int x, y;
	int seconds = 1000;
	int beeptime = 500;
	timer beeptimer, bombtimer;
	timer scantimer;
	bool d = false;
	player@ p;
	censor_bomb(int tx, int ty, int tz, mapdata@m, player@p) {
		x = tx;
		y = ty;
		z = tz;
		@map = m;
		@owner = @p;
	}
	bool censorcheck() {
		bool ret = false;
		if (@this.owner == null) return false;
		for (uint i2 = 0; i2 < players.length(); i2++) {
			if (players[i2].map != map.name) continue;
			if (get_3d_distance(x, y, z, players[i2].x, players[i2].y, players[i2].z) > 15) continue;
			if (are_teamed(owner.name, players[i2].name) or players[i2].is_dead or is_safe(players[i2].x, players[i2].y, players[i2].z, map) or players[i2].safe or players[i2].pvp == 0 or players[i2].away or players[i2].afk or players[i2].newb == 1 or players[i2].looking != "") continue;
			if (owner.pvp == 1 and players[i2].name != owner.name) {
				ret = true;
				break;
			}
		}
		return ret;
	}
	void loop(int i) {
		if (@map == null or @owner == null) {
			censor_bombs.remove_at(i);
			return;
		}
		if (scantimer.elapsed >= 1000) {
			scantimer.restart();
			send_packet(6, "play censor_bombscan.ogg " + x + " " + y + " " + z, x, y, z, map);
			bool t = d;
			d = censorcheck();
			if (t == false and d == true) {beeptimer.restart(); bombtimer.restart();}
		}
		if (d == true) {
			seconds = 3000 - bombtimer.elapsed;
			if (beeptimer.elapsed >= beeptime) {
				if (seconds > 300) d = censorcheck();
				beeptimer.restart();
				send_packet(6, "play censor_bombbeep.ogg " + x + " " + y + " " + z, x, y, z, map);
			}
			if (seconds <= 0) {
				send_packet(6, "play censor_bomb.ogg " + x + " " + y + " " + z, x, y, z, map);
				send_packet(6, "play censor_bombhit.ogg " + x + " " + y + " " + z, x, y, z, map);
				send_dpacket(6, "distsound censor_bombdist " + x + " " + y + " " + z + " " + map.name, maps[get_map_index(map.name)]);
				for (uint i2 = 0; i2 < players.length(); i2++) {
					if (players[i2].map != map.name) continue;
					if (get_3d_distance(x, y, z, players[i2].x, players[i2].y, players[i2].z) > 20) continue;
					if (are_teamed(owner.name, players[i2].name) or players[i2].is_dead or is_safe(players[i2].x, players[i2].y, players[i2].z, map) or players[i2].safe or players[i2].pvp == 0 or players[i2].away or players[i2].afk or players[i2].newb == 1 or players[i2].looking != "") continue;
					if (owner.pvp == 1) {
						players[i2].hit(2000, 8000);
						players[i2].should_subtract = false;
						players[i2].hitby = owner.name + "'s censor bomb";
						send_packet(6, "play censor_bombhit.ogg " + players[i2].x + " " + players[i2].y + " " + players[i2].z, players[i2].x, players[i2].y, players[i2].z, map);
					}
				}
				for (uint i2 = 0; i2 < ais.length(); i2++) {
					if (ais[i2].map.name == map.name and get_3d_distance(x, y, z, ais[i2].x, ais[i2].y, ais[i2].z) <= 20) {
						ais[i2].health -= random(2500, 6500);
						ais[i2].hitby = owner.name + "'s censor bomb";
						send_packet(6, "play h" + random(1, 5) + ".ogg " + ais[i2].x + " " + ais[i2].y + " " + ais[i2].z, ais[i2].x, ais[i2].y, ais[i2].z, maps[get_map_index(ais[i2].map.name)]);
					}
				}
				for (uint i2 = 0; i2 < houses.length(); i2++) {
					if (owner.pvp == 1 and houses[i2].map == map.name and get_3d_distance(x, y, z, houses[i2].x, houses[i2].y, houses[i2].z) <= 20) {
						send_packet(6, "play base_impact_ext.ogg " + houses[i2].x + " " + houses[i2].y + " " + houses[i2].z, houses[i2].x, houses[i2].y, houses[i2].z, maps[get_map_index(houses[i2].map)]);
						houses[i2].health -= random(2500, 6500);
						houses[i2].hitby = owner.name + "'s censor bomb";
					}
				}
				for (uint i2 = 0; i2 < lockers.length(); i2++) {
					if (owner.pvp == 1 and lockers[i2].map == map.name and get_3d_distance(x, y, z, lockers[i2].x, lockers[i2].y, lockers[i2].z) <= 20) {
						send_packet(6, "play locker_hit" + random(1, 6) + ".ogg " + lockers[i2].x + " " + lockers[i2].y + " " + lockers[i2].z, lockers[i2].x, lockers[i2].y, lockers[i2].z, maps[get_map_index(lockers[i2].map)]);
						lockers[i2].health -= random(2500, 6500);
						lockers[i2].hitby = owner.name + "'s censor bomb";
					}
				}
				for (uint i2 = 0; i2 < fridges.length(); i2++) {
					if (owner.pvp == 1 and fridges[i2].map == map.name and get_3d_distance(x, y, z, fridges[i2].x, fridges[i2].y, fridges[i2].z) <= 20) {
						send_packet(6, "play base_fridge_impact" + random(1, 3) + "", fridges[i2].x, fridges[i2].y, fridges[i2].z, maps[get_map_index(fridges[i2].map)]);
						fridges[i2].health -= random(2500, 6500);
						fridges[i2].hitby = owner.name + "'s censor bomb";
					}
				}
				for (uint i2 = 0; i2 < robots.length(); i2++) {
					if (owner.pvp == 1 and robots[i2].map.name == map.name and get_3d_distance(x, y, z, robots[i2].x, robots[i2].y, robots[i2].z) <= 20) {
						send_packet(6, "play locker_hit" + random(1, 6) + ".ogg " + robots[i2].x + " " + robots[i2].y + " " + robots[i2].z, robots[i2].x, robots[i2].y, robots[i2].z, maps[get_map_index(robots[i2].map.name)]);
						robots[i2].health -= random(2500, 6500);
						robots[i2].hitby = owner.name + "'s censor bomb";
					}
				}
				for (uint i2 = 0; i2 < microwaves.length(); i2++) {
					if (owner.pvp == 1 and microwaves[i2].map == map.name and get_3d_distance(x, y, z, microwaves[i2].x, microwaves[i2].y, microwaves[i2].z) <= 20) {
						send_packet(6, "play locker_hit" + random(1, 6) + ".ogg " + microwaves[i2].x + " " + microwaves[i2].y + " " + microwaves[i2].z, microwaves[i2].x, microwaves[i2].y, microwaves[i2].z, maps[get_map_index(microwaves[i2].map)]);
						microwaves[i2].health -= random(2500, 6500);
						microwaves[i2].hitby = owner.name + "'s censor bomb";
					}
				}
				for (uint i2 = 0; i2 < air_conditioners.length(); i2++) {
					if (owner.pvp == 1 and air_conditioners[i2].map == map.name and get_3d_distance(x, y, z, air_conditioners[i2].x, air_conditioners[i2].y, air_conditioners[i2].z) <= 20) {
						send_packet(6, "play locker_hit" + random(1, 6) + ".ogg " + air_conditioners[i2].x + " " + air_conditioners[i2].y + " " + air_conditioners[i2].z, air_conditioners[i2].x, air_conditioners[i2].y, air_conditioners[i2].z, maps[get_map_index(air_conditioners[i2].map)]);
						air_conditioners[i2].health -= random(2500, 6500);
						air_conditioners[i2].hitby = owner.name + "'s censor bomb";
					}
				}
				for (uint i2 = 0; i2 < steams.length(); i2++) {
					if (owner.pvp == 1 and steams[i2].map == map.name and get_3d_distance(x, y, z, steams[i2].x, steams[i2].y, steams[i2].z) <= 20) {
						send_packet(6, "play locker_hit" + random(1, 6) + ".ogg " + steams[i2].x + " " + steams[i2].y + " " + steams[i2].z, steams[i2].x, steams[i2].y, steams[i2].z, maps[get_map_index(steams[i2].map)]);
						steams[i2].health -= random(2500, 6500);
						steams[i2].hitby = owner.name + "'s censor bomb";
					}
				}
				for (uint i2 = 0; i2 < fans.length(); i2++) {
					if (owner.pvp == 1 and fans[i2].map == map.name and get_3d_distance(x, y, z, fans[i2].x, fans[i2].y, fans[i2].z) <= 20) {
						send_packet(6, "play locker_hit" + random(1, 6) + ".ogg " + fans[i2].x + " " + fans[i2].y + " " + fans[i2].z, fans[i2].x, fans[i2].y, fans[i2].z, maps[get_map_index(fans[i2].map)]);
						fans[i2].health -= random(2500, 6500);
						fans[i2].hitby = owner.name + "'s censor bomb";
					}
				}
				for (uint i2 = 0; i2 < playerstores.length(); i2++) {
					if (owner.pvp == 1 and playerstores[i2].map == map.name and get_3d_distance(x, y, z, playerstores[i2].x, playerstores[i2].y, playerstores[i2].z) <= 20) {
						send_packet(6, "play base_impact_ext.ogg " + playerstores[i2].x + " " + playerstores[i2].y + " " + playerstores[i2].z, playerstores[i2].x, playerstores[i2].y, playerstores[i2].z, maps[get_map_index(playerstores[i2].map)]);
						playerstores[i2].health -= random(2500, 6500);
						playerstores[i2].hitby = owner.name + "'s censor bomb";
					}
				}
				for (uint i2 = 0; i2 < beehives.length(); i2++) {
					if (owner.pvp == 1 and beehives[i2].map == map.name and get_3d_distance(x, y, z, beehives[i2].x, beehives[i2].y, beehives[i2].z) <= 20) {
						send_packet(6, "play base_impact_ext.ogg " + beehives[i2].x + " " + beehives[i2].y + " " + beehives[i2].z, beehives[i2].x, beehives[i2].y, beehives[i2].z, maps[get_map_index(beehives[i2].map)]);
						beehives[i2].health -= random(2500, 6500);
						beehives[i2].hitby = owner.name + "'s censor bomb";
					}
				}
				for (uint i2 = 0; i2 < objs.length(); i2++) {
					if (owner.pvp == 1 and objs[i2].map.name == map.name and get_3d_distance(x, y, z, objs[i2].x, objs[i2].y, objs[i2].z) <= 20) {
						send_packet(6, "play obj_break" + random(1, 3), objs[i2].x, objs[i2].y, objs[i2].z, maps[get_map_index(objs[i2].map.name)]);
						remove_obj(i2);
					}
				}
				censor_bombs.remove_at(i);
				return;
			}
		}
	}
}
void spawn_censor_bomb(int x, int y, int z, mapdata@m, player@p) {
	censor_bomb bomb(x, y, z, m, p);
	if (@bomb.map == null or @bomb.owner == null) return;
	else censor_bombs.insert_last(bomb);
}
void destroy_all_censor_bombs() {
	censor_bombs.resize(0);
}
string[] names;
double xp = 0;
double teampoints = 0;
double teamkills = 0;
string s = "";
string s2;
string[] outs;
nuclear_bomb@[] nuclear_bombs(0);
class nuclear_bomb {
	int x, y, z;
	mapdata@map;
	player@owner;
	timer bombaatomicatimer, tbipar1, tbipar2;
	int bombaatomicatime = 60000;
	nuclear_bomb(int cx, int cy, int cz, mapdata@m, player@p) {
		x = cx;
		y = cy;
		z = cz;
		@map = m;
		@owner = p;
		send_packet(6, "play nuclearbombplace.ogg " + x + " " + y + " " + z, x, y, z, map);
	}
	void loop(int i) {
		if (@map == null or @owner == null) {
			int index = get_player_index(nuclear_bombs[i].owner.peer_id);
			if (index > -1)
				nuclear_bombs[i].owner.nuclearbombspawned = 0;
			else {
				file f;
				f.open("chars/" + nuclear_bombs[i].owner.name + "/nbstats.usr", "wb");
				f.write(0);
				f.close();
			}
			nuclear_bombs.remove_at(i);
			return;
		}
		if (tbipar1.elapsed >= 10000 && bombaatomicatimer.elapsed < 50000) {
			tbipar1.restart();
			tbipar2.restart();
			send_packet(6, "play nuclearbombbeep.ogg " + x + " " + y + " " + z, x, y, z, map);
		}
		if (tbipar2.elapsed >= 1000 && bombaatomicatimer.elapsed >= 50000) {
			send_packet(6, "play nuclearbombbeep.ogg " + x + " " + y + " " + z, x, y, z, map);
			tbipar2.restart();
		}
		if (bombaatomicatimer.elapsed >= bombaatomicatime) {
			send_packet(6, "play nuclearbombexplode.ogg " + x + " " + y + " " + z, x, y, z, map);
			send_dpacket(6, "distsound nuclearbombexplode " + x + " " + y + " " + z + " " + map.name, maps[get_map_index(map.name)]);
			for (uint p = 0; p < players.length(); p++) {
				if (players[p].map != map.name) continue;
				if (are_teamed(owner.name, players[p].name) or players[p].is_dead or is_safe(players[p].x, players[p].y, players[p].z, map) or players[p].safe or players[p].pvp == 0 or players[p].away or players[p].afk or players[p].newb == 1 or players[p].looking != "") continue;
				if (players[p].name == owner.name) continue;
				if (owner.pvp == 1) {
					players[p].health -= random(5000, 10000);
					players[p].hitby = "nuclear_bomb_of_" + owner.name;
				}
			}
			for (uint i2 = 0; i2 < ais.length(); i2++) {
				if (ais[i2].nuclearbomb == false or ais[i2].aprotected) continue;
				names.insert_last("" + ais[i2].name + " on " + get_zone_at(ais[i2].x, ais[i2].y, ais[i2].z, maps[get_map_index(ais[i2].map.name)]) + "");
				xp += ais[i2].xp * owner.reinforcement;
				teampoints += random(20, 100);
				teamkills++;
				if (ais[i2].voice != "" and ais[i2].rapidvoice == true) destroy_moving_sound(ais[i2].voice);
				@ais[i2] = null;
				ais.remove_at(i2);
				i2--;
				return;
			}
			if (names.length() > 1) {
				for (uint i = 0; i < names.length(); i++) {
					if (i == (names.length() - 1)) s += "and " + names[i] + ".";
					else s += names[i] + ", ";
				}
			} else
				for (uint i = 0; i < names.length(); i++)
					s = names[i] + " ";
			s2 = " " + names.length() + " " + (names.length() > 1 ? "creatures were" : "creature was") + " killed by " + owner.name + "'s nuclear bomb: ";
			if (names.length() > 1) send_reliable(0, "kills " + s2 + s, 0);
			if (xp > 0) givexp(players[get_player_index_from(owner.name)], xp);
			if (teampoints > 0) {
				int t = is_in_team(owner.name);
				if (t > -1) {
					teams[t].teamkills += teamkills;
					teams[t].points += teampoints;
					teams[t].transmit("This team just got " + teampoints + " points!");
				}
			}
			names.resize(0);
			xp = 0;
			teampoints = 0;
			s = "";
			s2 = "";
			outs.resize(0);
			for (uint i2 = 0; i2 < houses.length(); i2++) {
				if (owner.pvp == 1 and houses[i2].map == map.name) {
					houses[i2].health -= random(10000, 100000);
					houses[i2].hitby = owner.name + "'s nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < beehives.length(); i2++) {
				if (owner.pvp == 1 and beehives[i2].map == map.name) {
					beehives[i2].health -= random(10000, 100000);
					beehives[i2].hitby = owner.name + "'s nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < playerstores.length(); i2++) {
				if (owner.pvp == 1 and playerstores[i2].map == map.name) {
					playerstores[i2].health -= random(10000, 100000);
					playerstores[i2].hitby = owner.name + "'s nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < lockers.length(); i2++) {
				if (owner.pvp == 1 and lockers[i2].map == map.name) {
					lockers[i2].health -= random(10000, 100000);
					lockers[i2].hitby = owner.name + "'s nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < fridges.length(); i2++) {
				if (owner.pvp == 1 and fridges[i2].map == map.name) {
					fridges[i2].health -= random(10000, 100000);
					fridges[i2].hitby = owner.name + "'s nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < microwaves.length(); i2++) {
				if (owner.pvp == 1 and microwaves[i2].map == map.name) {
					microwaves[i2].health -= random(10000, 100000);
					microwaves[i2].hitby = owner.name + "'s nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < air_conditioners.length(); i2++) {
				if (owner.pvp == 1 and air_conditioners[i2].map == map.name and get_3d_distance(x, y, z, air_conditioners[i2].x, air_conditioners[i2].y, air_conditioners[i2].z) <= 20) {
					air_conditioners[i2].health -= random(10000, 100000);
					air_conditioners[i2].hitby = owner.name + "'s nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < steams.length(); i2++) {
				if (owner.pvp == 1 and steams[i2].map == map.name and get_3d_distance(x, y, z, steams[i2].x, steams[i2].y, steams[i2].z) <= 20) {
					steams[i2].health -= random(10000, 100000);
					steams[i2].hitby = owner.name + "'s nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < fans.length(); i2++) {
				if (owner.pvp == 1 and fans[i2].map == map.name and get_3d_distance(x, y, z, fans[i2].x, fans[i2].y, fans[i2].z) <= 20) {
					fans[i2].health -= random(10000, 100000);
					fans[i2].hitby = owner.name + "'s nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < turrets.length(); i2++) {
				if (owner.pvp == 1 and turrets[i2].map.name == map.name) {
					names.insert_last("" + turrets[i2].owner.name + "'s turret " + turrets[i2].id + " on " + get_zone_at(turrets[i2].x, turrets[i2].y, turrets[i2].z, maps[get_map_index(turrets[i2].map.name)]) + "");
					xp += random(100, 300) * owner.reinforcement;
					teampoints += random(100, 300);
					@turrets[i2] = null;
					turrets.remove_at(i2);
					i2--;
					return;
				}
			} if (names.length() > 1) {
				for (uint i = 0; i < names.length(); i++) {
					if (i == (names.length() - 1)) s += "and " + names[i] + ".";
					else s += names[i] + ", ";
				}
			} else
				for (uint i = 0; i < names.length(); i++)
					s = names[i] + " ";
			s2 = " " + names.length() + " " + (names.length() > 1 ? "turrets were" : "turret was") + " destroyed by " + owner.name + "'s nuclear bomb: ";
			if (names.length() > 1) send_reliable(0, "kills " + s2 + s, 0);
			if (xp > 0) givexp(players[get_player_index_from(owner.name)], xp);
			if (teampoints > 0) {
				int t = is_in_team(owner.name);
				if (t > -1) {
					teams[t].points += teampoints;
					teams[t].transmit("This team just got " + teampoints + " points!");
				}
			}
			names.resize(0);
			xp = 0;
			teampoints = 0;
			s = "";
			s2 = "";
			outs.resize(0);
			int index = get_player_index(nuclear_bombs[i].owner.peer_id);
			if (index > -1)
				nuclear_bombs[i].owner.nuclearbombspawned = 0;
			else {
				file f;
				f.open("chars/" + nuclear_bombs[i].owner.name + "/nbstats.usr", "wb");
				f.write(0);
				f.close();
			}
			nuclear_bombs.remove_at(i);
			return;
		}
	}
}
void spawn_nuclear_bomb(int x, int y, int z, mapdata@m, player@p) {
	if (p.nuke_cooldown.elapsed < 60000) {
		int rem = (60000 - p.nuke_cooldown.elapsed) / 1000;
		send_reliable(p, "You must wait " + rem + " seconds before spawning another nuclear bomb.", 0);
		return;
	}
	p.nuke_cooldown.restart();
	nuclear_bomb bomb(x, y, z, m, p);
	if (@bomb.map == null or @bomb.owner == null) return;
	else nuclear_bombs.insert_last(bomb);
}
small_nuclear_bomb@[] small_nuclear_bombs(0);
class small_nuclear_bomb {
	int x, y, z;
	mapdata@map;
	player@owner;
	timer bombaatomicatimer, tbipar1, tbipar2;
	int bombaatomicatime = 60000;
	small_nuclear_bomb(int cx, int cy, int cz, mapdata@m, player@p) {
		x = cx;
		y = cy;
		z = cz;
		@map = m;
		@owner = p;
		send_packet(6, "play nuclearbombplace.ogg " + x + " " + y + " " + z, x, y, z, map);
	}
	void loop(int i) {
		if (@map == null or @owner == null) {
			int index = get_player_index(small_nuclear_bombs[i].owner.peer_id);
			if (index > -1)
				small_nuclear_bombs[i].owner.nuclearbombspawned = 0;
			else {
				file f;
				f.open("chars/" + small_nuclear_bombs[i].owner.name + "/nbstats.usr", "wb");
				f.write(0);
				f.close();
			}
			small_nuclear_bombs.remove_at(i);
			return;
		}
		if (tbipar1.elapsed >= 10000 && bombaatomicatimer.elapsed < 50000) {
			tbipar1.restart();
			tbipar2.restart();
			send_packet(6, "play nuclearbombbeep.ogg " + x + " " + y + " " + z, x, y, z, map);
		}
		if (tbipar2.elapsed >= 1000 && bombaatomicatimer.elapsed >= 50000) {
			send_packet(6, "play nuclearbombbeep.ogg " + x + " " + y + " " + z, x, y, z, map);
			tbipar2.restart();
		}
		if (bombaatomicatimer.elapsed >= bombaatomicatime) {
			send_packet(6, "play nuclearbombexplode.ogg " + x + " " + y + " " + z, x, y, z, map);
			send_dpacket(6, "distsound nuclearbombexplode " + x + " " + y + " " + z + " " + map.name, maps[get_map_index(map.name)]);
			for (uint p = 0; p < players.length(); p++) {
				if (players[p].map != map.name) continue;
				if (are_teamed(owner.name, players[p].name) or players[p].is_dead or is_safe(players[p].x, players[p].y, players[p].z, map) or players[p].safe or players[p].pvp == 0 or players[p].away or players[p].afk or players[p].newb == 1 or players[p].looking != "") continue;
				if (owner.pvp == 1) {
					players[p].health -= random(5000, 10000);
					players[p].hitby = "small_nuclear_bomb_of_" + owner.name;
				}
			}
			for (uint i2 = 0; i2 < ais.length(); i2++) {
				if (ais[i2].nuclearbomb == false or ais[i2].aprotected) continue;
				if (ais[i2].map.name == map.name) {
					names.insert_last("" + ais[i2].name + " on " + get_zone_at(ais[i2].x, ais[i2].y, ais[i2].z, maps[get_map_index(ais[i2].map.name)]) + "");
					xp += ais[i2].xp * owner.reinforcement;
					teampoints += random(20, 100);
					teamkills++;
					if (ais[i2].voice != "" and ais[i2].rapidvoice == true) destroy_moving_sound(ais[i2].voice);
					@ais[i2] = null;
					ais.remove_at(i2);
					i2--;
					return;
				}
			}
			if (names.length() > 1) {
				for (uint i = 0; i < names.length(); i++) {
					if (i == (names.length() - 1)) s += "and " + names[i] + ".";
					else s += names[i] + ", ";
				}
			} else
				for (uint i = 0; i < names.length(); i++)
					s = names[i] + " ";
			s2 = " " + names.length() + " " + (names.length() > 1 ? "creatures were" : "creature was") + " killed by " + owner.name + "'s small nuclear bomb: ";
			if (names.length() > 1) send_reliable(0, "kills " + s2 + s, 0);
			if (xp > 0) givexp(players[get_player_index_from(owner.name)], xp);
			if (teampoints > 0) {
				int t = is_in_team(owner.name);
				if (t > -1) {
					teams[t].teamkills += teamkills;
					teams[t].points += teampoints;
					teams[t].transmit("This team just got " + teampoints + " points!");
				}
			}
			names.resize(0);
			xp = 0;
			teampoints = 0;
			s = "";
			s2 = "";
			outs.resize(0);
			for (uint i2 = 0; i2 < houses.length(); i2++) {
				if (owner.pvp == 1 and houses[i2].map == map.name) {
					houses[i2].health -= random(10000, 100000);
					houses[i2].hitby = owner.name + "'s small nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < beehives.length(); i2++) {
				if (owner.pvp == 1 and beehives[i2].map == map.name) {
					beehives[i2].health -= random(10000, 100000);
					beehives[i2].hitby = owner.name + "'s small nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < playerstores.length(); i2++) {
				if (owner.pvp == 1 and playerstores[i2].map == map.name) {
					playerstores[i2].health -= random(10000, 100000);
					playerstores[i2].hitby = owner.name + "'s small nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < lockers.length(); i2++) {
				if (owner.pvp == 1 and lockers[i2].map == map.name) {
					lockers[i2].health -= random(10000, 100000);
					lockers[i2].hitby = owner.name + "'s small nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < fridges.length(); i2++) {
				if (owner.pvp == 1 and fridges[i2].map == map.name) {
					fridges[i2].health -= random(10000, 100000);
					fridges[i2].hitby = owner.name + "'s small nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < microwaves.length(); i2++) {
				if (owner.pvp == 1 and microwaves[i2].map == map.name) {
					microwaves[i2].health -= random(10000, 100000);
					microwaves[i2].hitby = owner.name + "'s small nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < air_conditioners.length(); i2++) {
				if (owner.pvp == 1 and air_conditioners[i2].map == map.name and get_3d_distance(x, y, z, air_conditioners[i2].x, air_conditioners[i2].y, air_conditioners[i2].z) <= 20) {
					air_conditioners[i2].health -= random(10000, 100000);
					air_conditioners[i2].hitby = owner.name + "'s small nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < steams.length(); i2++) {
				if (owner.pvp == 1 and steams[i2].map == map.name and get_3d_distance(x, y, z, steams[i2].x, steams[i2].y, steams[i2].z) <= 20) {
					steams[i2].health -= random(10000, 100000);
					steams[i2].hitby = owner.name + "'s small nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < fans.length(); i2++) {
				if (owner.pvp == 1 and fans[i2].map == map.name and get_3d_distance(x, y, z, fans[i2].x, fans[i2].y, fans[i2].z) <= 20) {
					fans[i2].health -= random(10000, 100000);
					fans[i2].hitby = owner.name + "'s small nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < turrets.length(); i2++) {
				if (owner.pvp == 1 and turrets[i2].map.name == map.name) {
					names.insert_last("" + turrets[i2].owner.name + "'s turret " + turrets[i2].id + " on " + get_zone_at(turrets[i2].x, turrets[i2].y, turrets[i2].z, maps[get_map_index(turrets[i2].map.name)]) + "");
					xp += random(100, 300) * owner.reinforcement;
					teampoints += random(100, 300);
					@turrets[i2] = null;
					turrets.remove_at(i2);
					i2--;
					return;
				}
			} if (names.length() > 1) {
				for (uint i = 0; i < names.length(); i++) {
					if (i == (names.length() - 1)) s += "and " + names[i] + ".";
					else s += names[i] + ", ";
				}
			} else
				for (uint i = 0; i < names.length(); i++)
					s = names[i] + " ";
			s2 = " " + names.length() + " " + (names.length() > 1 ? "turrets were" : "turret was") + " destroyed by " + owner.name + "'s small nuclear bomb: ";
			if (names.length() > 1) send_reliable(0, "kills " + s2 + s, 0);
			if (xp > 0) givexp(players[get_player_index_from(owner.name)], xp);
			if (teampoints > 0) {
				int t = is_in_team(owner.name);
				if (t > -1) {
					teams[t].points += teampoints;
					teams[t].transmit("This team just got " + teampoints + " points!");
				}
			}
			names.resize(0);
			xp = 0;
			teampoints = 0;
			s = "";
			s2 = "";
			outs.resize(0);
			int index = get_player_index(small_nuclear_bombs[i].owner.peer_id);
			if (index > -1)
				small_nuclear_bombs[i].owner.nuclearbombspawned = 0;
			else {
				file f;
				f.open("chars/" + small_nuclear_bombs[i].owner.name + "/nbstats.usr", "wb");
				f.write(0);
				f.close();
			}
			small_nuclear_bombs.remove_at(i);
			return;
		}
	}
}
void spawn_small_nuclear_bomb(int x, int y, int z, mapdata@m, player@p) {
	if (p.nuke_cooldown.elapsed < 60000) {
		int rem = (60000 - p.nuke_cooldown.elapsed) / 1000;
		send_reliable(p, "You must wait " + rem + " seconds before spawning another nuclear bomb.", 0);
		return;
	}
	p.nuke_cooldown.restart();
	small_nuclear_bomb bomb(x, y, z, m, p);
	if (@bomb.map == null or @bomb.owner == null) return;
	else small_nuclear_bombs.insert_last(bomb);
}
large_nuclear_bomb@[] large_nuclear_bombs(0);
class large_nuclear_bomb {
	int x, y, z;
	mapdata@map;
	player@owner;
	timer bombaatomicatimer, tbipar1, tbipar2;
	int bombaatomicatime = 60000;
	large_nuclear_bomb(int cx, int cy, int cz, mapdata@m, player@p) {
		x = cx;
		y = cy;
		z = cz;
		@map = m;
		@owner = p;
		send_packet(6, "play nuclearbombplace.ogg " + x + " " + y + " " + z, x, y, z, map);
	}
	void loop(int i) {
		if (@map == null or @owner == null) {
			int index = get_player_index(large_nuclear_bombs[i].owner.peer_id);
			if (index > -1)
				large_nuclear_bombs[i].owner.nuclearbombspawned = 0;
			else {
				file f;
				f.open("chars/" + large_nuclear_bombs[i].owner.name + "/nbstats.usr", "wb");
				f.write(0);
				f.close();
			}
			large_nuclear_bombs.remove_at(i);
			return;
		}
		if (tbipar1.elapsed >= 10000 && bombaatomicatimer.elapsed < 50000) {
			tbipar1.restart();
			tbipar2.restart();
			send_packet(6, "play nuclearbombbeep.ogg " + x + " " + y + " " + z, x, y, z, map);
		}
		if (tbipar2.elapsed >= 1000 && bombaatomicatimer.elapsed >= 50000) {
			send_packet(6, "play nuclearbombbeep.ogg " + x + " " + y + " " + z, x, y, z, map);
			tbipar2.restart();
		}
		if (bombaatomicatimer.elapsed >= bombaatomicatime) {
			send_packet(6, "play nuclearbombexplode.ogg " + x + " " + y + " " + z, x, y, z, map);
			send_dpacket(6, "distsound nuclearbombexplode " + x + " " + y + " " + z + " " + map.name, maps[get_map_index(map.name)]);
			for (uint p = 0; p < players.length(); p++) {
				if (players[p].map != map.name) continue;
				if (are_teamed(owner.name, players[p].name) or players[p].is_dead or is_safe(players[p].x, players[p].y, players[p].z, map) or players[p].safe or players[p].pvp == 0 or players[p].away or players[p].afk or players[p].newb == 1 or players[p].looking != "") continue;
				if (players[p].name == owner.name) continue;
				if (owner.pvp == 1) {
					players[p].health -= random(20000, 50000);
					players[p].hitby = "large_nuclear_bomb_of_" + owner.name;
				}
			}
			for (uint i2 = 0; i2 < ais.length(); i2++) {
				if (ais[i2].aprotected) continue;
				names.insert_last("" + ais[i2].name + " on " + get_zone_at(ais[i2].x, ais[i2].y, ais[i2].z, maps[get_map_index(ais[i2].map.name)]) + "");
				xp += ais[i2].xp * owner.reinforcement;
				teampoints += random(20, 100);
				teamkills++;
				if (ais[i2].voice != "" and ais[i2].rapidvoice == true) destroy_moving_sound(ais[i2].voice);
				@ais[i2] = null;
				ais.remove_at(i2);
				i2--;
				return;
			}
			if (names.length() > 1) {
				for (uint i = 0; i < names.length(); i++) {
					if (i == (names.length() - 1)) s += "and " + names[i] + ".";
					else s += names[i] + ", ";
				}
			} else
				for (uint i = 0; i < names.length(); i++)
					s = names[i] + " ";
			s2 = " " + names.length() + " " + (names.length() > 1 ? "creatures were" : "creature was") + " killed by " + owner.name + "'s large nuclear bomb: ";
			if (names.length() > 1) send_reliable(0, "kills " + s2 + s, 0);
			if (xp > 0) givexp(players[get_player_index_from(owner.name)], xp);
			if (teampoints > 0) {
				int t = is_in_team(owner.name);
				if (t > -1) {
					teams[t].teamkills += teamkills;
					teams[t].points += teampoints;
					teams[t].transmit("This team just got " + teampoints + " points!");
				}
			}
			names.resize(0);
			xp = 0;
			teampoints = 0;
			s = "";
			s2 = "";
			outs.resize(0);
			for (uint i2 = 0; i2 < houses.length(); i2++) {
				if (owner.pvp == 1 and houses[i2].map == map.name) {
					houses[i2].health -= random(10000, 100000);
					houses[i2].hitby = owner.name + "'s large nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < beehives.length(); i2++) {
				if (owner.pvp == 1 and beehives[i2].map == map.name) {
					beehives[i2].health -= random(10000, 100000);
					beehives[i2].hitby = owner.name + "'s large nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < playerstores.length(); i2++) {
				if (owner.pvp == 1 and playerstores[i2].map == map.name) {
					playerstores[i2].health -= random(10000, 100000);
					playerstores[i2].hitby = owner.name + "'s large nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < lockers.length(); i2++) {
				if (owner.pvp == 1 and lockers[i2].map == map.name) {
					lockers[i2].health -= random(10000, 100000);
					lockers[i2].hitby = owner.name + "'s large nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < fridges.length(); i2++) {
				if (owner.pvp == 1 and fridges[i2].map == map.name) {
					fridges[i2].health -= random(10000, 100000);
					fridges[i2].hitby = owner.name + "'s large nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < microwaves.length(); i2++) {
				if (owner.pvp == 1 and microwaves[i2].map == map.name) {
					microwaves[i2].health -= random(10000, 100000);
					microwaves[i2].hitby = owner.name + "'s large nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < air_conditioners.length(); i2++) {
				if (owner.pvp == 1 and air_conditioners[i2].map == map.name and get_3d_distance(x, y, z, air_conditioners[i2].x, air_conditioners[i2].y, air_conditioners[i2].z) <= 20) {
					air_conditioners[i2].health -= random(10000, 100000);
					air_conditioners[i2].hitby = owner.name + "'s large nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < steams.length(); i2++) {
				if (owner.pvp == 1 and steams[i2].map == map.name and get_3d_distance(x, y, z, steams[i2].x, steams[i2].y, steams[i2].z) <= 20) {
					steams[i2].health -= random(10000, 100000);
					steams[i2].hitby = owner.name + "'s large nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < fans.length(); i2++) {
				if (owner.pvp == 1 and fans[i2].map == map.name and get_3d_distance(x, y, z, fans[i2].x, fans[i2].y, fans[i2].z) <= 20) {
					fans[i2].health -= random(10000, 100000);
					fans[i2].hitby = owner.name + "'s large nuclear bomb";
				}
			}
			for (uint i2 = 0; i2 < turrets.length(); i2++) {
				if (owner.pvp == 1 and turrets[i2].map.name == map.name) {
					names.insert_last("" + turrets[i2].owner.name + "'s turret " + turrets[i2].id + " on " + get_zone_at(turrets[i2].x, turrets[i2].y, turrets[i2].z, maps[get_map_index(turrets[i2].map.name)]) + "");
					xp += random(100, 300) * owner.reinforcement;
					teampoints += random(100, 300);
					@turrets[i2] = null;
					turrets.remove_at(i2);
					i2--;
					return;
				}
			} if (names.length() > 1) {
				for (uint i = 0; i < names.length(); i++) {
					if (i == (names.length() - 1)) s += "and " + names[i] + ".";
					else s += names[i] + ", ";
				}
			} else
				for (uint i = 0; i < names.length(); i++)
					s = names[i] + " ";
			s2 = " " + names.length() + " " + (names.length() > 1 ? "turrets were" : "turret was") + " destroyed by " + owner.name + "'s large nuclear bomb: ";
			if (names.length() > 1) send_reliable(0, "kills " + s2 + s, 0);
			if (xp > 0) givexp(players[get_player_index_from(owner.name)], xp);
			if (teampoints > 0) {
				int t = is_in_team(owner.name);
				if (t > -1) {
					teams[t].points += teampoints;
					teams[t].transmit("This team just got " + teampoints + " points!");
				}
			}
			names.resize(0);
			xp = 0;
			teampoints = 0;
			s = "";
			s2 = "";
			outs.resize(0);
			int index = get_player_index(large_nuclear_bombs[i].owner.peer_id);
			if (index > -1)
				large_nuclear_bombs[i].owner.nuclearbombspawned = 0;
			else {
				file f;
				f.open("chars/" + large_nuclear_bombs[i].owner.name + "/nbstats.usr", "wb");
				f.write(0);
				f.close();
			}
			large_nuclear_bombs.remove_at(i);
			return;
		}
	}
}
void spawn_large_nuclear_bomb(int x, int y, int z, mapdata@m, player@p) {
	if (p.nuke_cooldown.elapsed < 60000) {
		int rem = (60000 - p.nuke_cooldown.elapsed) / 1000;
		send_reliable(p, "You must wait " + rem + " seconds before spawning another nuclear bomb.", 0);
		return;
	}
	p.nuke_cooldown.restart();
	large_nuclear_bomb bomb(x, y, z, m, p);
	if (@bomb.map == null or @bomb.owner == null) return;
	else large_nuclear_bombs.insert_last(bomb);
}
time_bomb@[] time_bombs(0);
class time_bomb {
	player@owner;
	int z;
	mapdata@map;
	int x, y;
	int seconds = 40000;
	int beeptime;
	timer beeptimer, bombtimer;
	time_bomb(int bx, int by, int bz, mapdata@m, player@p) {
		@owner = p;
		x = bx;
		y = by;
		z = bz;
		@map = m;
		send_packet(6, "play timebombdrop.ogg " + x + " " + y + " " + z, x, y, z, map);
	}
	void loop(int i) {
		if (@map == null or @owner == null) {
			time_bombs.remove_at(i);
			return;
		}
		seconds = 3000 - bombtimer.elapsed;
		beeptime = seconds / 5 + 50;
		if (beeptimer.elapsed >= beeptime) {
			beeptimer.restart();
			send_packet(6, "play timebombbeep.ogg " + x + " " + y + " " + z, x, y, z, map);
		}
		if (seconds <= 0) {
			send_packet(6, "play timebombexplode.ogg " + x + " " + y + " " + z, x, y, z, map);
			send_dpacket(6, "distsound timebombdist " + x + " " + y + " " + z + " " + map.name, maps[get_map_index(map.name)]);
			for (uint i2 = 0; i2 < players.length(); i2++) {
				if (players[i2].map != map.name) continue;
				if (get_3d_distance(x, y, z, players[i2].x, players[i2].y, players[i2].z) > 25) continue;
				if (are_teamed(owner.name, players[i2].name) or players[i2].is_dead or is_safe(players[i2].x, players[i2].y, players[i2].z, map) or players[i2].safe or players[i2].pvp == 0 or players[i2].away or players[i2].afk or players[i2].newb == 1 or players[i2].looking != "") continue;
				if (owner.pvp == 1) {
					players[i2].health -= random(2500, 6500);
					players[i2].hitby = owner.name + "'s time bomb";
					send_packet(6, "play timebombhit.ogg " + players[i2].x + " " + players[i2].y + " " + players[i2].z, players[i2].x, players[i2].y, players[i2].z, map);
				}
			}
			for (uint i2 = 0; i2 < ais.length(); i2++) {
				if (ais[i2].map.name != map.name) continue;
				if (get_3d_distance(x, y, z, ais[i2].x, ais[i2].y, ais[i2].z) > 25) continue;
				ais[i2].health -= random(600, 1800);
				ais[i2].hitby = owner.name + "'s time bomb";
				send_packet(6, "play hit" + random(1, 5), ais[i2].x, ais[i2].y, ais[i2].z, map);
			}
			for (uint i2 = 0; i2 < houses.length(); i2++) {
				if (houses[i2].map != map.name) continue;
				if (get_3d_distance(x, y, z, houses[i2].x, houses[i2].y, houses[i2].z) > 25) continue;
				if (owner.pvp == 1) {
					send_packet(6, "play base_impact_ext.ogg " + houses[i2].x + " " + houses[i2].y + " " + houses[i2].z, houses[i2].x, houses[i2].y, houses[i2].z, map);
					houses[i2].health -= random(2500, 6500);
					houses[i2].hitby = owner.name + "'s time bomb";
				}
			}
			for (uint i2 = 0; i2 < lockers.length(); i2++) {
				if (lockers[i2].map != map.name) continue;
				if (get_3d_distance(x, y, z, lockers[i2].x, lockers[i2].y, lockers[i2].z) > 25) continue;
				if (owner.pvp == 1) {
					send_packet(6, "play locker_hit" + random(1, 6) + ".ogg " + lockers[i2].x + " " + lockers[i2].y + " " + lockers[i2].z, lockers[i2].x, lockers[i2].y, lockers[i2].z, map);
					lockers[i2].health -= random(2500, 6500);
					lockers[i2].hitby = owner.name + "'s time bomb";
				}
			}
			for (uint i2 = 0; i2 < fridges.length(); i2++) {
				if (fridges[i2].map != map.name) continue;
				if (get_3d_distance(x, y, z, fridges[i2].x, fridges[i2].y, fridges[i2].z) > 25) continue;
				if (owner.pvp == 1) {
					send_packet(6, "play base_fridge_impact" + random(1, 3) + "", fridges[i2].x, fridges[i2].y, fridges[i2].z, map);
					fridges[i2].health -= random(2500, 6500);
					fridges[i2].hitby = owner.name + "'s time bomb";
				}
			}
			for (uint i2 = 0; i2 < robots.length(); i2++) {
				if (robots[i2].map.name != map.name) continue;
				if (get_3d_distance(x, y, z, robots[i2].x, robots[i2].y, robots[i2].z) > 25) continue;
				if (owner.pvp == 1) {
					send_packet(6, "play locker_hit" + random(1, 6) + ".ogg " + robots[i2].x + " " + robots[i2].y + " " + robots[i2].z, robots[i2].x, robots[i2].y, robots[i2].z, map);
					robots[i2].health -= random(2500, 6500);
					robots[i2].hitby = owner.name + "'s time bomb";
				}
			}
			for (uint i2 = 0; i2 < microwaves.length(); i2++) {
				if (microwaves[i2].map != map.name) continue;
				if (get_3d_distance(x, y, z, microwaves[i2].x, microwaves[i2].y, microwaves[i2].z) > 25) continue;
				if (owner.pvp == 1) {
					send_packet(6, "play locker_hit" + random(1, 6) + ".ogg " + microwaves[i2].x + " " + microwaves[i2].y + " " + microwaves[i2].z, microwaves[i2].x, microwaves[i2].y, microwaves[i2].z, map);
					microwaves[i2].health -= random(2500, 6500);
					microwaves[i2].hitby = owner.name + "'s time bomb";
				}
			}
			for (uint i2 = 0; i2 < air_conditioners.length(); i2++) {
				if (air_conditioners[i2].map != map.name) continue;
				if (get_3d_distance(x, y, z, air_conditioners[i2].x, air_conditioners[i2].y, air_conditioners[i2].z) > 25) continue;
				if (owner.pvp == 1) {
					send_packet(6, "play locker_hit" + random(1, 6) + ".ogg " + air_conditioners[i2].x + " " + air_conditioners[i2].y + " " + air_conditioners[i2].z, air_conditioners[i2].x, air_conditioners[i2].y, air_conditioners[i2].z, map);
					air_conditioners[i2].health -= random(2500, 6500);
					air_conditioners[i2].hitby = owner.name + "'s time bomb";
				}
			}
			for (uint i2 = 0; i2 < steams.length(); i2++) {
				if (steams[i2].map != map.name) continue;
				if (get_3d_distance(x, y, z, steams[i2].x, steams[i2].y, steams[i2].z) > 25) continue;
				if (owner.pvp == 1) {
					send_packet(6, "play locker_hit" + random(1, 6) + ".ogg " + steams[i2].x + " " + steams[i2].y + " " + steams[i2].z, steams[i2].x, steams[i2].y, steams[i2].z, map);
					steams[i2].health -= random(2500, 6500);
					steams[i2].hitby = owner.name + "'s time bomb";
				}
			}
			for (uint i2 = 0; i2 < fans.length(); i2++) {
				if (fans[i2].map != map.name) continue;
				if (get_3d_distance(x, y, z, fans[i2].x, fans[i2].y, fans[i2].z) > 25) continue;
				if (owner.pvp == 1) {
					send_packet(6, "play locker_hit" + random(1, 6) + ".ogg " + fans[i2].x + " " + fans[i2].y + " " + fans[i2].z, fans[i2].x, fans[i2].y, fans[i2].z, map);
					fans[i2].health -= random(2500, 6500);
					fans[i2].hitby = owner.name + "'s time bomb";
				}
			}
			for (uint i2 = 0; i2 < playerstores.length(); i2++) {
				if (playerstores[i2].map != map.name) continue;
				if (get_3d_distance(x, y, z, playerstores[i2].x, playerstores[i2].y, playerstores[i2].z) > 25) continue;
				if (owner.pvp == 1) {
					send_packet(6, "play base_impact_ext.ogg " + playerstores[i2].x + " " + playerstores[i2].y + " " + playerstores[i2].z, playerstores[i2].x, playerstores[i2].y, playerstores[i2].z, map);
					playerstores[i2].health -= random(2500, 6500);
					playerstores[i2].hitby = owner.name + "'s time bomb";
				}
			}
			for (uint i2 = 0; i2 < beehives.length(); i2++) {
				if (beehives[i2].map != map.name) continue;
				if (get_3d_distance(x, y, z, beehives[i2].x, beehives[i2].y, beehives[i2].z) > 25) continue;
				if (owner.pvp == 1) {
					send_packet(6, "play base_impact_ext.ogg " + beehives[i2].x + " " + beehives[i2].y + " " + beehives[i2].z, beehives[i2].x, beehives[i2].y, beehives[i2].z, map);
					beehives[i2].health -= random(2500, 6500);
					beehives[i2].hitby = owner.name + "'s time bomb";
				}
			}
			time_bombs.remove_at(i);
			return;
		}
	}
}
void spawn_time_bomb(int x, int y, int z, mapdata@m, player@p) {
	time_bomb bomb(x, y, z, m, p);
	if (@bomb.map == null or @bomb.owner == null) return;
	else time_bombs.insert_last(bomb);
}
void destroy_all_time_bombs() {
	time_bombs.resize(0);
}
