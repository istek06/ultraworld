/* nv_form.nvgt - audio form rewrite(with some code taken from the original form)
 *
 * NVGT - NonVisual Gaming Toolkit
 * Copyright (c) 2022-2025 Sam Tupy
 * https://nvgt.gg
 * nv_form - Copyright (C) 2025 Ivan Soto
 * This software is provided "as-is", without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.
 * Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:
 * 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
*/

#include "enums.nvgt"
#include "helper.nvgt"
#include "nv_form_funcdefs.nvgt"
#include "speech.nvgt"
#include "controls/*.nvgt"
#include "base_control.nvgt"
#include "utilities.nvgt"

string nvform_word_separators = "_ .,!\\\"/[{()}]=\n:";
class nv_form {
	nv_form_control@[]controls;
	int max_controls = 0;
	int control_index = -1;
	string window_title;
	bool speak_control_attributes_separately = false;
	bool active = false;
	private nv_form_errorcode[] errors;
	nv_form_control@primary_control = null, cancel_control = null;
	nv_form_callback@background_callback = null;
	nv_form() {
		this.reset();
	}
	void reset() {
		this.window_title = "";
		this.active = false;
		this.controls.resize(0);
		@this.primary_control = null;
		@this.cancel_control = null;
		@this.nv_utility_form = null;
	}
	nv_form_control@get_control_by_id(const string&in id) {
		if (this.controls.length() <= 0) return null;
		for (uint i = 0; i < this.controls.length(); i += 1) {
			if (this.controls[i].id == id) return this.controls[i];
		}
		return null;
	}
	nv_form_control@get_current_control() const property {
		if (this.controls.length() <= 0 or this.control_index < 0) return null;
		return @this.controls[this.control_index];
	}
	nv_form_control@find_next_control(bool next = true) {
		if (this.controls.length() == 0) return null;
		int index = this.control_index;
		while (true) {
			index += (next ? 1 : -1);
			if (index < 0 or index >= this.controls.length())
				index = (index >= this.controls.length() ? 0 : this.controls.length() - 1);
			if (@this.controls[index] != null and !this.controls[index].hidden)
				return this.controls[index];
		}
		return null;
	}
	bool create_window(string title, bool change_screen_title = true, bool say_dialog = true, bool silent = false) {
		if (this.active) {
			this.error(nv_form_error_already_active);
			return false;
		} else if (title.empty()) {
			this.error(nv_form_error_invalid_operation);
			return false;
		}
		this.window_title = title;
		get_characters();
		this.active = true;
		if (change_screen_title) show_window(this.window_title);
		if (!silent)
			speak(window_title + (say_dialog ? "  dialog" : ""), false);
		return true;
	}
	bool check_controls(nv_form_control@&out ctrl = void) {
		if (this.controls.length() <= 0) return false;
		bool result = false;
		for (uint i = 0; i < this.controls.length(); i += 1) {
			if (this.controls[i].monitor()) {
				result = true;
				@ctrl = this.controls[i];
				break;
			}
		}
		return result;
	}
	bool monitor() {
		if (!this.active) return false;
		if (@this.nv_utility_form != null) {
			this.nv_utility_form.monitor();
			return true;
		}
		this.handle_input();
		nv_form_control@ctrl;
		bool result = this.check_controls(ctrl);
		if (result and @ctrl != null and (@this.cancel_control != null and @ctrl == this.cancel_control)) return false;
		return true;
	}
	void handle_input() {
		nv_form_control@ ctrl = this.current_control;
		nv_form_control@ pctrl = this.primary_control;
		if (@ctrl != null) ctrl.handle_input();
		if (@pctrl != null && pctrl.type != nv_form_ct_keyboard_area && ((@ctrl != null && ctrl.type != nv_form_ct_keyboard_area && !ctrl.handle_input()) || @ctrl == null) && (key_pressed(KEY_RETURN) || key_pressed(KEY_NUMPAD_ENTER))) pctrl.fire();
		if (key_pressed(KEY_ESCAPE) and @this.cancel_control != null) this.cancel_control.fire();
		if (key_repeating(KEY_TAB)) {
			bool next_control = true;
			if (key_down(KEY_LSHIFT) or key_down(KEY_RSHIFT)) next_control = false;
			this.navigate_form(next_control);
		}
		foreach (nv_form_control@ l: this.controls) {
			if (@l == null || @l.shortcut == null) continue;
			if (l.check_shortcut()) {
				this.focus_control(l);
				break;
			}
		}
	}
	void error(nv_form_errorcode error) {
		this.errors.insert_last(error);
	}
	nv_form_errorcode get_last_error() const property {
		if (this.errors.length() <= 0) return nv_form_error_none;
		return this.errors[this.errors.length() - 1];
	}
	//helper functions.
	bool is_pressed(string control_id) {
		nv_form_control@ctrl = this.get_control_by_id(control_id);
		if (@ctrl == null || (ctrl.type != nv_form_ct_button && ctrl.type != nv_form_ct_link)) {
			this.error(nv_form_error_invalid_control);
			return false;
		}
		nv_form_button@btn = cast < nv_form_button@ > (ctrl);
		nv_form_link@link = cast < nv_form_link@ > (ctrl);
		if (@btn == null && @link == null) {
			this.error(nv_form_error_invalid_control);
			return false;
		}
		else if (@btn != null) return this.is_pressed(btn);
		else if (@link != null) return this.is_pressed(link);
		return false;
	}
	bool is_pressed(nv_form_button@btn) {
		if (@btn.parent != this) {
			this.error(nv_form_error_invalid_control);
			return false;
		}
		bool result = btn.pressed;
		if (result) btn.pressed = false;
		return result;
	}
	bool is_pressed(nv_form_link@link) {
		if (@link.parent != this) {
			this.error(nv_form_error_invalid_control);
			return false;
		}
		bool result = link.pressed;
		if (result) link.pressed = false;
		return result;
	}
	bool is_checked(string control_id) {
		nv_form_checkbox@box = cast < nv_form_checkbox@ > (this.get_control_by_id(control_id));
		if (@box == null) {
			this.error(nv_form_error_invalid_control);
			return false;
		}
		return this.is_checked(box);
	}
	bool is_checked(nv_form_checkbox@box) {
		if (@box.parent != this) {
			this.error(nv_form_error_invalid_control);
			return false;
		}
		return box.state;
	}
	nv_form_list_item@get_list_focus(string control_id) {
		return this.get_list_focus(cast < nv_form_list_box@ > (this.get_control_by_id(control_id)));
	}
	nv_form_list_item@get_list_focus(nv_form_list_box@lst) {
		if (@lst == null or @lst.parent != this) {
			this.error(nv_form_error_invalid_control);
			return null;
		}
		return lst.focused_item;
	}
	nv_form_switch_item@get_switch_focus(string control_id) {
		return this.get_switch_focus(cast < nv_form_switch@ > (this.get_control_by_id(control_id)));
	}
	nv_form_switch_item@get_switch_focus(nv_form_switch@lst) {
		if (@lst == null or @lst.parent != this) {
			this.error(nv_form_error_invalid_control);
			return null;
		}
		return lst.focused_item;
	}
	double get_slider_value(string control_id, double def = 0) {
		return this.get_slider_value(cast < nv_form_slider@ > (this.get_control_by_id(control_id)), def);
	}
	double get_slider_value(nv_form_slider@slider, double def = 0) {
		if (@slider == null or @slider.parent != this) {
			this.error(nv_form_error_invalid_control);
			return def;
		}
		return slider.value;
	}
	nv_form_button@add_button(string caption, string id = "", bool primary = false, bool cancel = false, int position = -1, nv_form_control_callback@callback = null) {
		nv_form_button@btn = nv_form_button(this, caption, id);
		bool added = this.add_control(btn, primary, cancel, position, @callback);
		if (added) return btn;
		return null;
	}
	nv_form_link@add_link(string caption, string url, string id = "", bool primary = false, bool cancel = false, int position = -1, nv_form_control_callback@callback = null) {
		nv_form_link@link = nv_form_link(this, caption, url, id);
		bool added = this.add_control(link, primary, cancel, position, @callback);
		if (added) return link;
		return null;
	}
	nv_form_input@add_input(string caption, string id = "", string default_text = "", string password_mask = "", int max_length = 0, bool read_only = false, bool multiline = false, int position = -1, nv_form_control_callback@callback = null) {
		nv_form_input@inp = nv_form_input(this, caption, id);
		inp.password_mask = password_mask;
		inp.max_length = max_length;
		inp.default_text = default_text;
		inp.read_only = read_only;
		inp.multiline = multiline;
		bool added = this.add_control(inp, false, false, position, @callback);
		if (added) return inp;
		return null;
	}
	nv_form_checkbox@add_checkbox(string caption, string id = "", bool selected = false, int position = -1) {
		nv_form_checkbox@checkbox = nv_form_checkbox(this, caption, id, selected);
		bool added = this.add_control(checkbox, position = position);
		if (added) return checkbox;
		return null;
	}
	nv_form_list_box@add_list(string caption, string id = "", bool multiselect = false, nv_form_list_item@[] items = {}, int max_items = 0, int position = -1, bool speak_position = false) {
		nv_form_list_box@lst = nv_form_list_box(this, caption, id, multiselect, items, max_items, speak_position);
		bool added = this.add_control(lst, position = position);
		if (added) return lst;
		return null;
	}
	nv_form_switch@add_switch(string caption, string id = "", nv_form_switch_item@[] items = {}, int position = -1) {
		nv_form_switch@ lst = nv_form_switch(this, caption, id, items);
		bool added = this.add_control(lst, position = position);
		if (added) return lst;
		return null;
	}
	nv_form_slider@add_slider(string caption, string id = "", double min_value = 0, double max_value = 100, double step_size = 1, double initial_value = 0, double page_size = 0, int position = -1) {
		nv_form_slider slide(this, caption, id, min_value, max_value, step_size, initial_value, page_size);
		bool added = this.add_control(@slide, position = position);
		if (added) return slide;
		return null;
	}
	nv_form_progress_bar@add_progress_bar(string caption, string id = "", double min = 0, double max = 100, double initial = 0.0, int position = -1) {
		nv_form_progress_bar@bar = nv_form_progress_bar(@this, caption, id, min, max, initial);
		bool added = this.add_control(@bar, position = position);
		if (added) return bar;
		return null;
	}
	nv_form_keyboard_area@add_keyboard_area(string caption, string id = "", int position = -1) {
		nv_form_keyboard_area area(@this, caption, id);
		bool added = this.add_control(@area, position = position);
		if (added) return area;
		return null;
	}
	bool add_control(nv_form_control@ctrl, bool primary = false, bool cancel = false, int position = -1, nv_form_control_callback@callback = null) {
		if (!this.active) {
			this.error(nv_form_error_no_window);
			return false;
		}
		if (this.max_controls > 0 and this.controls.length() >= this.max_controls) {
			this.error(nv_form_error_window_full);
			return false;
		}
		if (@ctrl == null) {
			this.error(nv_form_error_invalid_control);
			return false;
		}
		if (@callback != null) @ctrl.callback = callback;
		if (position < 0) this.controls.insert_last(ctrl);
		else this.controls.insert_at(position, ctrl);
		if (primary) @this.primary_control = @ctrl;
		if (cancel) @this.cancel_control = @ctrl;
		return true;
	}
	bool navigate_form(bool next = true) {
		nv_form_control@ctrl = this.find_next_control(next);
		return this.focus_control(ctrl);
	}
	bool focus_control(nv_form_control@ctrl, bool quiet = false, bool interrupt_previous_speech = true) {
		if (@ctrl == null) return false;
		int index = this.controls.find_by_ref(ctrl);
		if (index == -1) return false;
		return this.set_focus(index, quiet, interrupt_previous_speech);
	}
	private bool set_focus(int control_index, bool quiet = false, bool interrupt_previous_speech = true) {
		if (control_index<0 or control_index >= this.controls.length()) return false;
		this.control_index = control_index;
		bool result;
		if (!quiet) result = this.speak_current_control(interrupt_previous_speech);
		else result = true;
		this.current_control.on_focus_gained();
		return result;
	}
	string get_fixed_type(nv_form_control@ ctrl) {
		if (@ctrl == null) return "";
		string f;
		if (ctrl.custom_type != "") f = ctrl.custom_type;
		else f = get_nv_form_control_type_string(ctrl.type);
		string t = ctrl.fixed_type_last;
		string t2 = ctrl.fixed_type_first;
		if (t != "") f += " " + t;
		if (t2 != "") f.insert(0, t2 + " ");
		return f;
	}
	bool speak_current_control(bool interrupt = true) {
		if (this.control_index == -1) return false;
		nv_form_control@ctrl = this.controls[this.control_index];
		if (@ctrl == null) return false;
		string[] texts = {ctrl.caption, this.get_fixed_type(ctrl)};
		if (!ctrl.enabled) texts.insert_last(" unavailable");
		if (@ctrl.shortcut != null && ctrl.speak_shortcut) texts.insert_last(ctrl.shortcut.name);
		if (!this.speak_control_attributes_separately) {
			texts.insert_last("  " + ctrl.get_control_info());
			return speak(join(texts, "  "), interrupt);
		} else {
			speak(join(texts, "  "), interrupt);
			speak(ctrl.get_control_info(), false);
			return true;
		}
	}
	bool search(nv_form_control@ ctrl, const string& in text, int dir = 1, bool silent = false) {
		nv_form_input@ ctrl_input = cast < nv_form_input@ > (ctrl);
		nv_form_list_box@ ctrl_list = cast < nv_form_list_box@ > (ctrl);
		if (@ctrl_input != null) return ctrl_input.search(text, dir, silent);
		else if (@ctrl_list != null) return ctrl_list.search(text, dir, silent);
		return false;
	}
	// Below lines are intended for this class and should not be modified in subsequence scripts.
	nv_utility_form@ nv_utility_form = null;
	dictionary nv_utility_form_data;
}
