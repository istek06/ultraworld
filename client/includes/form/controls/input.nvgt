class nv_form_input: nv_form_control {
	string text;
	string __default_text__;
	string password_mask;
	string highlight_select_speech_text = "selected", highlight_unselect_speech_text = "unselected", delete_speech_text = "";
	int cursor = 0;
	int sel_start = -1;
	int sel_end = -1;
	int max_length = 0;
	bool read_only = false;
	bool multiline = false;
	bool overwrite = false;
	bool enable_delete = true;
	string delete_disabled_message = "This input has disabled deletion";
	int echo_flag = textflag_entry_characters;
	uint8 clipboard_flags = nv_clipboard_flag_copy | nv_clipboard_flag_cut | nv_clipboard_flag_paste;
	string[] disallowed_chars;
	bool use_only_disallowed_chars = false;
	string char_disallowed_description = "";
	nv_form_input(nv_form@parent, string caption, string id = "") {
		super(caption, id, nv_form_ct_input, @parent);
	}
	string get_control_info() {
		string f;
		if (password_mask != "") {
			if (text.length() > 0)
				f = text.length() + " characters";
			else
				f = "Blank";
		}
		if (password_mask == "") {
			if (text.length() > 0) {
				if (sel_start >= 0) {
					if (sel_end - sel_start >= 1024)
						f = highlight_select_speech_text + " " + (sel_end - sel_start + 1) + " characters";
					else
						f = highlight_select_speech_text + " " + text.substr(sel_start, sel_end - sel_start + 1);
				} else
					f = read_line(current_line_start_position());
			} else
				f = "Blank";
		}
		return f;
	}
	string get_fixed_type_first() property {
		string[] f;
		if (this.read_only) f.insert_last("read only");
		return join(f, " ");
	}
	string get_fixed_type_last() property {
		string[] f;
		if (this.password_mask != "") f.insert_last("protected");
		if (this.multiline) f.insert_last("multi line");
		return join(f, " ");
	}
	bool handle_input() {
		if (@this.parent.current_control != @this) return false;
		string char;
		char = get_characters();
		if (!this.read_only) {
			if (char != "") {
				if (this.disallowed_chars.length() > 0 && this.is_disallowed_char(char)) {
					if (this.char_disallowed_description != "") speak(this.char_disallowed_description);
					return true;
				}
				if (overwrite)
					edit(char);
				else
					add(char);
				return true;
			}
			if ((keyboard_modifiers & KEYMOD_SHIFT > 0) && (key_pressed(KEY_RETURN) || key_pressed(KEY_NUMPAD_ENTER))) {
				this.add_new_line();
				return true;
			}
			if ((clipboard_flags & nv_clipboard_flag_cut > 0) && (keyboard_modifiers & KEYMOD_CTRL > 0) && (key_repeating(KEY_X)) && password_mask == "") {
				cut_highlighted();
				return true;
			}
			if ((clipboard_flags & nv_clipboard_flag_paste > 0) && (keyboard_modifiers & KEYMOD_CTRL > 0) && (key_repeating(KEY_V)) || key_pressed(KEY_PASTE)) {
				paste_text();
				return true;
			}
			if (key_repeating(KEY_BACK)) {
				if (!enable_delete) {
					speak(delete_disabled_message);
					return true;
				}
				if ((keyboard_modifiers & KEYMOD_CTRL > 0) && (sel_start < 0 || sel_end < 0 || sel_start > sel_end)) {
					delete_word_left();
					return true;
				}
				delete_highlighted();
				return true;
			}
			if (key_repeating(KEY_DELETE)) {
				if (!enable_delete) {
					speak(delete_disabled_message);
					return true;
				}
				if ((keyboard_modifiers & KEYMOD_CTRL > 0) && (sel_start < 0 || sel_end < 0 || sel_start > sel_end)) {
					delete_word_right();
					return true;
				}
				delete_highlighted(1);
				return true;
			}
		}
		if (((key_down(KEY_LCTRL)) || (key_down(KEY_RCTRL))) && key_up(KEY_LSHIFT) && key_up(KEY_RSHIFT) && (key_repeating(KEY_A))) {
			highlight_all();
			return true;
		}
		if ((clipboard_flags & nv_clipboard_flag_copy > 0) && (keyboard_modifiers & KEYMOD_CTRL > 0) && (key_repeating(KEY_C)) && (password_mask == "")) {
			copy_highlighted();
			return true;
		}
		if (key_repeating(KEY_LEFT)) {
			if ((key_down(KEY_LCTRL)) || (key_down(KEY_RCTRL))) {
				if (password_mask == "") {
					if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT)))
						move_word_left(true);
					else
						move_word_left();
				}
				return true;
			}
			if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT))) {
				highlight_left();
				return true;
			}
			move_left();
			return true;
		}
		if (key_repeating(KEY_RIGHT)) {
			if ((key_down(KEY_LCTRL)) || (key_down(KEY_RCTRL))) {
				if (password_mask == "") {
					if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT)))
						move_word_right(true);
					else
						move_word_right();
				}
				return true;
			}
			if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT))) {
				highlight_right();
				return true;
			}
			move_right();
			return true;
		}
		if (key_repeating(KEY_UP)) {
			if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT)) && password_mask == "")
				highlight_up();
			else
				previous_line();
			return true;
		}
		if (key_repeating(KEY_DOWN)) {
			if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT)) && password_mask == "")
				highlight_down();
			else
				next_line();
			return true;
		}
		if (key_repeating(KEY_HOME)) {
			if ((key_down(KEY_LCTRL)) || (key_down(KEY_RCTRL)) || (multiline == false)) {
				if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT)))
					highlight_to_field_start();
				else {
					if (!multiline)
						line_start();
					else
						field_start();
				}
			} else {
				if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT)))
					highlight_to_line_start();
				else
					line_start();
			}
			return true;
		}
		if (key_repeating(KEY_END)) {
			if ((key_down(KEY_LCTRL)) || (key_down(KEY_RCTRL)) || (multiline == false)) {
				if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT)))
					highlight_to_field_end();
				else {
					if (!multiline)
						line_end();
					else
						field_end();
				}
			} else {
				if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT)))
					highlight_to_line_end();
				else
					line_end();
			}
			return true;
		}
		if (handle_nv_utils(this)) return true;
		return false;
	}
	void on_focus_gained() {
		get_characters(); // Cleanup any characters that might have been accumulated.
	}
	bool add(string character, bool silent = false) {
		string new_text = text;
		if (sel_start > -1 && sel_end > -1) {
			cursor = sel_start;
			new_text = text.substr(0, cursor) + text.substr(sel_end + 1);
			sel_start = -1;
			sel_end = -1;
		}
		if ((max_length > 0) && (new_text.length() >= max_length))
			return false;
		new_text = new_text.substr(0, cursor) + character + new_text.substr(cursor);
		if (read_only == false) {
			text = new_text;
			cursor += character.length();
		}
		if (echo_flag == textflag_entry_characters || echo_flag == textflag_entry_characters_words)
			speak(input_box_speak(find_appropriate_character(character)), true);
		if (nvform_word_separators .find(character) > -1 && (echo_flag == textflag_entry_words || echo_flag == textflag_entry_characters_words)) {
			int temp_position = cursor - 1;
			while (temp_position > 0 && (temp_position >= text.length() || nvform_word_separators .find(text[temp_position - 1]) < 0 && text[temp_position - 1] != "\n"))
				temp_position--;
			string word = read_word_from_position(temp_position);
			if (password_mask != "") {
				for (uint i = 0; i < word.length(); i++) word[i] = password_mask;
			}
			speak(word, echo_flag != textflag_entry_characters_words);
		}
		return true;
	}
	bool edit(string character) {
		if ((max_length > 0) && (text.length() > max_length))
			return false;
		if (text.length() == 0)
			return false;
		if (cursor >= text.length())
			return false;
		if (read_only == false)
			text[cursor] = character;
		if (echo_flag == textflag_entry_characters || echo_flag == textflag_entry_characters_words)
			speak(input_box_speak(find_appropriate_character(character)), true);
		if (nvform_word_separators .find(character) > -1 && (echo_flag == textflag_entry_words || echo_flag == textflag_entry_characters_words)) {
			int temp_position = cursor - 1;
			while (temp_position > 0 && (temp_position >= text.length() || nvform_word_separators .find(text[temp_position - 1]) < 0))
				temp_position--;
			speak(read_word_from_position(temp_position), echo_flag != textflag_entry_characters_words);
		}
		return true;
	}
	string input_box_speak(string character) {
		return input_box_speak(character, false);
	}
	string input_box_speak(string character, bool ignore_echo_flag) {
		if (character == " ")
			return "Space";
		if (character == "\n")
			return "Blank";
		if (character == "-")
			return "Dash";
		if (character == ".")
			return "Dot";
		if (character == ",")
			return "Comma";
		if (character == "@")
			return "At";
		if (character == ">")
			return "Greater";
		if (character == ";")
			return "Semicolon";
		if (character == ":")
			return "Colon";
		if (character == "\t")
			return "Tab";
		if (character == "'")
			return "Apostrophe";
		if (character == "<")
			return "Less";
		if (character == "_")
			return "Underline";
		if (character == "+")
			return "Plus";
		if (character == "=")
			return "Equals";
		if (character == "!")
			return "Exclamation Mark";
		if (character == "\"")
			return "Quote";
		if (character == "\\")
			return "Backslash";
		if (character == "/")
			return "Slash";
		if (character == "£")
			return "Pounds";
		if (character == "$")
			return "Dollar";
		if (character == "%")
			return "Percent";
		if (character == "^")
			return "Carret";
		if (character == "&")
			return "And";
		if (character == "*")
			return "Star";
		if (character == "(")
			return "Left Parenthesis";
		if (character == ")")
			return "Right Parenthesis";
		if (character == "[")
			return "Left Bracket";
		if (character == "]")
			return "Right Bracket";
		if (character == "{")
			return "Left Brace";
		if (character == "}")
			return "Right Brace";
		if (character == "|")
			return "Bar";
		if (character == "?")
			return "Question Mark";
		if (character == "`")
			return "Grave";
		if (character == "¬")
			return "Not";
		if (character == "#")
			return "Number";
		if (character == "~")
			return "Tilda";
		if ((echo_flag == textflag_entry_none) && (ignore_echo_flag == false))
			return "";
		if (character.is_alphanumeric()) {
			if (character.is_upper())
				return "Capital " + character + " ";
			else
				return character + " ";
		}
		return character + " ";
	}
	string find_appropriate_character(string original_character) {
		original_character.resize(utf8size(original_character));
		if (password_mask == "")
			return original_character;
		else
			return password_mask;
	}
	void move_left() {
		sel_start = -1;
		sel_end = -1;
		cursor = utf8prev(text, cursor);
		if (cursor < 0)
			cursor = 0;
		if (cursor >= text.length())
			speak("Blank");
		else
			speak(input_box_speak(find_appropriate_character(text.substr(cursor, 4)), true), true);
	}
	void move_right() {
		sel_start = -1;
		sel_end = -1;
		cursor = utf8next(text, cursor);
		if (cursor > text.length())
			cursor = text.length();
		if (cursor >= text.length())
			speak("Blank");
		else
			speak(input_box_speak(find_appropriate_character(text.substr(cursor, 4)), true), true);
	}
	void add_new_line() {
		if (!this.multiline)
			return;
		add("\n");
		if (this.echo_flag != textflag_entry_none)
			speak("New Line", true);
	}
	int current_line_start_position(bool word = false) {
		if (this.text == "")
			return -1;
		int i = cursor;
		while (i<text.length() and word and i >= 0 and nvform_word_separators .find(text[i]) > -1)
			i--;
		for (i; i > -1; i--) {
			if (i >= text.length() || i == cursor && !word && text[cursor] == "\n")
				continue;
			if (i <= 0) {
				if (i == 0 && text[i] == "\n")
					return i + 1;
				else
					return i;
			} else if (!word && text[i] == "\n" || (word && nvform_word_separators .find(text[i]) > -1))
				return i + 1;
		}
		return 0;
	}
	string read_line(int position) {
		string temp = "";
		if (position < 0) position = 0;
		for (int counter = position; counter < text.length(); counter++) {
			if (text[counter] != "\n")
				temp += text[counter];
			else
				break;
		}
		if (temp == "")
			return "Blank";
		if (password_mask != "")
			return temp.length() + " characters";
		return temp;
	}
	void line_start() {
		if (cursor == 0) {
			if (text != "")
				speak(input_box_speak(find_appropriate_character(text.substr(0, 4)), true));
			else
				speak("Blank");
			return;
		}
		int line_start = current_line_start_position();
		if (line_start < text.length()) {
			cursor = line_start;
			speak(input_box_speak(find_appropriate_character(text.substr(cursor, 4)), true));
		}
		sel_start = -1;
		sel_end = -1;
	}
	void line_end() {
		int i = cursor;
		for (i = cursor; i <= text.length(); i++) {
			if (i == text.length() or text[i] == "\n") break;
		}
		cursor = i;
		speak("Blank");
		sel_start = -1;
		sel_end = -1;
	}
	void move_word_left(bool highlighting = false, bool speak_selection_status = true) {
		if (text == "") {
			if (speak_selection_status) speak("Blank");
			return;
		}
		if (highlighting) {
			if (cursor < 1)
				return;
			int pos = current_line_start_position(true);
			while (cursor == pos) {
				int tmp_cursor = cursor;
				cursor = pos - 2;
				pos = current_line_start_position(true);
				cursor = tmp_cursor;
			}
			if (sel_start == -1 && sel_end == -1 || cursor == sel_start || cursor - 1 == sel_start) {
				sel_start = pos;
				if (sel_end == -1)
					sel_end = cursor - 1;
				if (speak_selection_status) speak_selected(text.substr(sel_start, cursor - sel_start));
				else speak(text.substr(sel_start, cursor - sel_start), true, null);
				cursor = sel_start;
				return;
			} else if (cursor == sel_end || cursor - 1 == sel_end) {
				sel_end = pos - 1;
				if (speak_selection_status) speak(text.substr(pos, cursor - 1 - pos) + " " + highlight_unselect_speech_text, true, null);
				else speak(text.substr(pos, cursor - 1 - pos), true, null);
				cursor = pos;
				return;
			}
		}
		if (cursor <= 0) {
			speak(read_word_from_position(0), true, null);
			return;
		}
		int cur_word = current_line_start_position(true);
		while (cursor == cur_word) {
			int tmp_cursor = cursor;
			cursor = cur_word - 2;
			cur_word = current_line_start_position(true);
			cursor = tmp_cursor;
		}
		cursor = cur_word;
		speak(read_word_from_position(cur_word), true, null);
	}
	void move_word_right(bool highlighting = false, bool speak_selection_status = true) {
		if (text == "" || cursor < 0 || cursor >= text.length()) {
			if (speak_selection_status) speak("Blank");
			return;
		}
		bool found_boundary = nvform_word_separators .find(text[cursor]) > -1;
		int new_word = -1;
		for (uint i = cursor; i < text.length(); i++) {
			if (nvform_word_separators .find(text[i]) > -1)
				found_boundary = true;
			else if (found_boundary && nvform_word_separators .find(text[i]) < 0) {
				new_word = i;
				break;
			}
		}
		if (new_word == -1)
			new_word = text.length();
		//if(highlighting&&new_word>0)
		//new_word-=1;
		if (highlighting) {
			if (sel_start == -1 && sel_end == -1 || cursor == sel_end || cursor - 1 == sel_end) {
				if (sel_start == -1)
					sel_start = cursor;
				sel_end = new_word - 1;
				if (speak_selection_status) speak_selected(text.substr(cursor, new_word - cursor));
				else speak(text.substr(cursor, new_word - cursor), true, null);
				cursor = new_word;
				return;
			} else if (cursor == sel_start || cursor - 1 == sel_start) {
				if (speak_selection_status) speak(text.substr(sel_start, new_word - sel_start) + " " + highlight_unselect_speech_text, true, null);
				else speak(text.substr(sel_start, new_word - sel_start), true, null);
				sel_start = new_word;
				cursor = new_word;
				return;
			}
		}
		cursor = new_word;
		if (cursor < text.length())
			speak(read_word_from_position(cursor), true, null);
		else
			speak("Blank");
	}
	void field_start() {
		cursor = 0;
		sel_start = -1;
		sel_end = -1;
		if (text.length() == 0) {
			speak("Blank", true);
			return;
		}
		speak(read_line(0), true, null);
	}
	void field_end() {
		sel_start = -1;
		sel_end = -1;
		if (text.length() == 0) {
			speak("Blank", true);
			return;
		}
		cursor = text.length();
		int line_start = current_line_start_position();
		speak(read_line(line_start), true, null);
	}
	string read_word_from_position(int position) {
		if (text == "")
			return "";
		int word_end = 0;
		for (int counter = position; counter < text.length(); counter++) {
			if (word_end < 1 && (nvform_word_separators .find(text[counter]) > -1 || text[counter] == "\n"))
				word_end = counter;
			else if (word_end > 0 && (nvform_word_separators .find(text[counter]) < 0) && (text[counter] != "\n")) {
				word_end = counter;
				break;
			}
		}
		return text.substr(position, word_end - position);
	}
	void highlight_to_field_start() {
		if (cursor == 0)
			return;
		sel_start = 0;
		sel_end = cursor;
		cursor = 0;
		speak_selected(text.substr(0, sel_end + 1));
	}
	void highlight_to_field_end() {
		if (cursor >= text.length())
			return;
		sel_start = cursor;
		sel_end = text.length() - 1;
		cursor = text.length();
		speak_selected(text.substr(sel_start));
	}
	void highlight_to_word_start() {
	}
	void highlight_to_word_end() {
	}
	void highlight_to_line_start(bool continuation = false) {
		if (cursor == 0)
			return;
		if (cursor == text.length())
			cursor -= 1;
		if (cursor == text.length() - 1 && cursor >= 0 && text[cursor] == "\n" && !continuation)
			cursor -= 1;
		int line_start = current_line_start_position();
		if (cursor <= line_start) {
			if (!continuation)
				return;
			else {
				int tmp_cursor = cursor;
				cursor = line_start - 1;
				line_start = current_line_start_position();
				if (line_start < 0) line_start = 0;
				cursor = tmp_cursor;
			}
		}
		if (sel_start < 0 || cursor == sel_start || cursor - 1 == sel_start) {
			sel_start = line_start;
			if (!continuation || sel_end == -1)
				sel_end = cursor;
			speak_selected(text.substr(sel_start, cursor - sel_start));
			cursor = sel_start;
		} else if (cursor == sel_end || cursor - 1 == sel_end) {
			sel_end = line_start;
			speak(text.substr(sel_end, cursor - sel_end) + " " + highlight_unselect_speech_text, true, null);
			cursor = sel_end;
		}
		if (sel_end < sel_start) {
			sel_start = -1;
			sel_end = -1;
		}
	}
	void highlight_to_line_end(bool continuation = false) {
		if (cursor >= text.length() - 1)
			return;
		int line_end = cursor + 1;
		for (line_end; line_end < text.length(); line_end++) {
			if (text[line_end] == "\r" || text[line_end] == "\n")
				break;
		}
		if (sel_end == line_end) {
			if (!continuation)
				return;
			else {
				if (text[line_end] == "\r") line_end += 2;
				else if (text[line_end] == "\n") line_end += 1;
				for (line_end; line_end < text.length(); line_end++) {
					if (text[line_end] == "\r" || text[line_end] == "\n")
						break;
				}
			}
		}
		//line_end-=1;
		if (sel_start < 0 || cursor == sel_end || cursor - 1 == sel_end) {
			if (!continuation or sel_start == -1)
				sel_start = cursor;
			sel_end = line_end;
			int old_cursor = cursor;
			cursor = line_end;
			speak_selected(text.substr(old_cursor, sel_end - old_cursor));
		} else if (cursor == sel_start || cursor - 1 == sel_start) {
			sel_start = line_end;
			speak(text.substr(cursor, line_end - cursor) + " " + highlight_unselect_speech_text, true, null);
			cursor = line_end;
		}
		if (sel_end < sel_start) {
			sel_start = -1;
			sel_end = -1;
		}
	}
	void highlight_left() {
		if (cursor <= 0)
			return;
		if (sel_start < 0) {
			sel_start = utf8prev(text, cursor);
			sel_end = sel_start;
			speak(input_box_speak(find_appropriate_character(text.substr(sel_start, 4)), true) + " " + highlight_select_speech_text, true);
			return;
		}
		int old_cursor = cursor;
		if (cursor > 0)
			cursor = utf8prev(text, cursor);
		if ((cursor == sel_start || old_cursor == sel_start) && sel_start > 0) {
			sel_start = utf8prev(text, sel_start);
			speak(input_box_speak(find_appropriate_character(text.substr(sel_start, 4)), true) + " " + highlight_select_speech_text, true);
		} else if (cursor == sel_end || (old_cursor == sel_end) && sel_end > 0 && sel_end < text.length()) {
			speak(input_box_speak(find_appropriate_character(text.substr(sel_end, 4)), true) + " " + highlight_unselect_speech_text, true);
			sel_end = utf8prev(text, sel_end);
		}
		if (sel_end < sel_start && sel_start > -1) {
			sel_start = -1;
			sel_end = -1;
		}
	}
	void highlight_right() {
		if (text == "")
			return;
		if (sel_start == -1 && sel_end == -1 && cursor < text.length()) {
			sel_start = cursor;
			sel_end = cursor;
			speak(input_box_speak(find_appropriate_character(text.substr(sel_start, 4)), true) + " " + highlight_select_speech_text, true);
			cursor = utf8next(text, cursor);
			return;
		}
		if (utf8prev(text, cursor) == sel_end && cursor < text.length()) {
			sel_end = utf8next(text, sel_end);
			speak(input_box_speak(find_appropriate_character(text.substr(sel_end, 4)), true) + " " + highlight_select_speech_text, true);
		} else if ((cursor == sel_start || utf8prev(text, cursor) == sel_start) && cursor <= text.length() && sel_start > -1) {
			speak(input_box_speak(find_appropriate_character(text.substr(sel_start, 4)), true) + " " + highlight_unselect_speech_text, true);
			sel_start = utf8next(text, sel_start);
		}
		if (cursor < text.length())
			cursor = utf8next(text, cursor);
		if (sel_end < sel_start && sel_start > -1) {
			sel_start = -1;
			sel_end = -1;
		}
	}
	void highlight_up() {
		highlight_to_line_start(true);
	}
	void highlight_down() {
		highlight_to_line_end(true);
	}
	void highlight_by_position(int start, int end) {
		sel_start = start;
		sel_end = end;
	}
	void next_line() {
		sel_start = -1;
		sel_end = -1;
		if (!multiline) {
			cursor = text.length();
			speak(read_line(0), true, null);
			return;
		}
		int line_start = current_line_start_position();
		if (line_start == text.length() || line_start < 0) {
			speak("Blank", true);
			if (line_start == text.length())
				cursor = text.length();
			return;
		}
		for (int counter = cursor; counter < text.length(); counter++) {
			if (text[counter] != "\n")
				continue;
			cursor = counter + 1;
			speak(read_line(cursor), true, null);
			return;
		}
		speak(read_line(line_start), true, null);
		cursor = text.length();
	}
	void previous_line() {
		sel_start = -1;
		sel_end = -1;
		int line_start = current_line_start_position();
		if (line_start <= 0 || !multiline) {
			cursor = 0;
			if (text == "")
				speak("Blank");
			else
				speak(read_line(0), true, null);
			return;
		}
		cursor = line_start - 1;
		cursor = current_line_start_position();
		if (cursor < 0)
			cursor = 0;
		speak(read_line(cursor), true, null);
	}
	void highlight_all() {
		if (text == "") {
			sel_start = -1;
			sel_end = -1;
			speak("nothing to select");
			return;
		}
		sel_start = 0;
		sel_end = text.length() - 1;
		cursor = 0;
		speak_selected(text);
	}
	protected void speak_selected(const string& in selection) {
		if (selection.length() >= 1024 || password_mask != "")
			speak(selection.length() + " characters " + highlight_select_speech_text);
		else
			speak(selection + " " + highlight_select_speech_text, true);
	}
	void copy_highlighted() {
		if (sel_start < 0 || sel_end < 0 || sel_start > sel_end) {
			speak("Nothing selected", true);
			return;
		}
		string copy_text = text.substr(0, sel_end + 1).substr(sel_start);
		speak("Copied to clipboard", true);
		clipboard_set_text(copy_text);
	}
	void cut_highlighted() {
		if (read_only == true) {
			speak("Cannot cut from a read only edit box.", true);
			return;
		}
		if (sel_start < 0 || sel_end < 0 || sel_start > sel_end) {
			speak("Nothing selected", true);
			return;
		}
		string copy_text = text.substr(0, sel_end + 1).substr(sel_start);
		speak("Cut Selected", true);
		clipboard_set_text(copy_text);
		delete_highlighted(0, false);
	}
	void paste_text() {
		string paste = clipboard_get_text();
		string[]@ paste_single = paste.split("\r\n", false);
		if (!multiline)
			paste = paste_single[0];
		paste = paste.replace("\r", "", true);
		if (paste == "") {
			speak("clipboard empty", true);
			return;
		}
		if ((max_length > 0) && ((text + paste).length() - (sel_end - sel_start) > max_length)) {
			speak("clipboard data can't fit", true);
			return;
		}
		if (this.disallowed_chars.length() > 0 && this.is_disallowed_char(paste)) {
			if (this.char_disallowed_description != "") speak(this.char_disallowed_description);
			return;
		}
		string new_text = text;
		if (sel_start > -1 && sel_end > -1) {
			cursor = sel_start;
			new_text = text.substr(0, cursor) + text.substr(sel_end + 1);
			sel_start = -1;
			sel_end = -1;
		}
		text = new_text.substr(0, cursor) + paste + new_text.substr(cursor);
		cursor += paste.length();
		speak("Text Pasted", true);
	}
	void delete_word_left() {
		move_word_left(true, false);
		delete_highlighted(0, false);
	}
	void delete_word_right() {
		move_word_right(true, false);
		delete_highlighted(0, false);
	}
	void delete_highlighted() {
		delete_highlighted(0);
	}
	void delete_highlighted(int from_start) {
		delete_highlighted(from_start, true);
	}
	void delete_highlighted(int from_start, bool speak_deleted) {
		if ((text == "") || (read_only == true))
			return;
		if (sel_start > -1 && sel_end > -1 && sel_start <= sel_end) {
			cursor = sel_start;
			text = text.substr(0, cursor) + text.substr(sel_end + 1);
			sel_start = -1;
			sel_end = -1;
			if (speak_deleted)
				speak("selection deleted");
			return;
		} else if (from_start == 0 && cursor > 0) {
			int old_cursor = cursor;
			cursor = utf8prev(text, cursor);
			if (cursor >= text.length())
				cursor = text.length() - 1;
			if (speak_deleted)
				speak(input_box_speak(find_appropriate_character(text.substr(cursor, 4)), true) + (delete_speech_text != "" ? " " + delete_speech_text : ""), true);
			text = text.substr(0, cursor) + text.substr(old_cursor);
		} else if (from_start == 1) {
			string del_char = "Blank";
			if (cursor < text.length())
				del_char = text.substr(cursor, 4);
			text = text.substr(0, cursor) + text.substr(cursor + utf8size(text.substr(cursor, 1)));
			if (speak_deleted)
				speak(input_box_speak(find_appropriate_character(del_char), true), true);
		}
	}
	bool select(int sel_start = -1, int sel_end = -1) {
		this.sel_start = sel_start;
		if (sel_start >= 0 && sel_end < 0)
			sel_end = this.text.length() - 1;
		this.sel_end = sel_end;
		return true;
	}
	int get_line_number() {
		int ln = 1;
		for (uint i = 0; i < text.length() and i < cursor; i++) {
			if (text[i] == "\n") ln++;
		}
		return ln;
	}
	int get_line_column() {
		int col = 1;
		for (int i = cursor - 1; i >= 0 and i < text.length(); i--) {
			if (text[i] == "\n") break;
			col++;
		}
		return col;
	}
	bool set_line(int line, int col = 1, bool silent = false) {
		if (col < 1) col = 1;
		int max_col = col;
		int pos = 0;
		if (line > 1)
			pos = nv_string_contains(text, "\n", line - 1);
		if (pos > -1) {
			int pos2 = nv_string_contains(text, "\n", line);
			if (pos2 > -1) max_col = pos2 - pos - 1;
		} else {
			if (!silent) speak("line number out of range");
			return false;
		}
		if (col > max_col) col = max_col;
		if (pos == 0) col--;
		pos += col;
		cursor = pos;
		sel_start = -1;
		sel_end = -1;
		if (!silent) speak(read_line(current_line_start_position()), false);
		return true;
	}
	string get_default_text() property {
		return this.__default_text__;
	}
	void set_default_text(string v) property {
		if ((this.max_length > 0) && (v.length() > this.max_length))
			v = v.substr(0, this.max_length);
		this.__default_text__ = v;
		this.text = v;
	}
	bool search(const string& in text, int dir = 1, bool silent = false) {
		string wrapped = "";
		int idx = dir > 0 ? this.text.find(text, cursor + dir) : this.text.rfind(text, cursor + dir);
		if (idx < 0) {
			int tmp_cursor = dir > 0 ? 0 : this.text.length() - 1;
			wrapped = dir > 0 ? "wrapped to top" : "wrapped to bottom";
			idx = dir > 0 ? this.text.find(text, tmp_cursor) : this.text.rfind(text, tmp_cursor);
		}
		if (idx < 0) {
			if (!silent) speak("nothing found");
			return false;
		}
		if (cursor == idx) {
			if (!silent) speak("nothing else found");
			return false;
		}
		cursor = idx;
		sel_start = -1;
		sel_end = -1;
		if (!silent) {
			if (wrapped != "") speak(wrapped);
			speak(read_line(current_line_start_position()), wrapped == "");
		}
		return true;
	}
	bool set_disallowed_chars(string chars, bool use_only_disallowed_chars = false, string char_disallowed_description = "") {
		if (chars.length() < 1)
			this.disallowed_chars.resize(0);
		else {
			for (uint i = 0; i < chars.length(); i++)
				this.disallowed_chars.insert_last(chars[i]);
		}
		this.use_only_disallowed_chars = use_only_disallowed_chars;
		this.char_disallowed_description = char_disallowed_description;
		return true;
	}
	bool is_disallowed_char(string char, bool search_all = true) {
		if (char.length() < 1)
			return false;
		if (search_all) {
			for (uint i = 0; i < char.length(); i++) {
				if (this.disallowed_chars.find(char[i]) < 0 && this.use_only_disallowed_chars) return true;
				else if (this.disallowed_chars.find(char[i]) > -1 && !this.use_only_disallowed_chars) return true;
			}
			return false;
		}
		return (this.disallowed_chars.find(char) > -1 && !this.use_only_disallowed_chars) or (this.disallowed_chars.find(char) < 0 && this.use_only_disallowed_chars);
	}
}
