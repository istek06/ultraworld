reverb_effect@[]reverb_effects(0);
sound_pool rvp;
sound_pool@[] pools(0);
class reverb_effect {
	vector min, max;
	float dry_mix;
	float wet_mix;
	float room_size;
	float dampping;
	float width;
	string reverb_id;
	reverb_effect(vector m1, vector m2, string rd, float dm, float wm, float rs, float dp, float wt) {
		this.min = m1;
		this.max = m2;
		this.reverb_id = rd;
		this.dry_mix = dm;
		this.wet_mix = wm;
		this.room_size = rs;
		this.dampping = dp;
		this.width = wt;
	}
}
void revfxloop(vector w, vector wa) {
	bool reverb_applied = false;
	string applied_reverb_id = "";
	for (uint i = 0; i < reverb_effects.length(); i++) {
		reverb_effect@ r = @reverb_effects[i];
		if (inrange(w, r.min, r.max) || inrange(wa, r.min, r.max)) {
			if (!reverb_applied) {
				string fxtype = "$" + r.reverb_id + ":freeverb:" + r.dry_mix + ":" + r.wet_mix + ":" + r.room_size + ":" + r.dampping + ":" + r.width;
				for (uint j = 0; j < pools.length(); j++)
					pools[j].mixer.set_fx(fxtype);
				reverb_applied = true;
				applied_reverb_id = r.reverb_id;
			}
		}
	}
	if (!reverb_applied) {
		foreach (sound_pool@ j: pools) {
			if (@j == null) continue;
			j.mixer.set_fx("$");
		}
	} else {
		for (uint i = 0; i < reverb_effects.length(); i++) {
			if (reverb_effects[i].reverb_id != applied_reverb_id) {
				foreach (sound_pool@ j: pools) {
					if (@j == null) continue;
					j.mixer.set_fx("$" + reverb_effects[i].reverb_id);
				}
			}
		}
	}
}
void spawn_reverb_effect(vector m1, vector m2, string reverb_id, float dry_mix, float wet_mix, float room_size, float dampping, float width) {
	reverb_effect rf1(m1, m2, reverb_id, dry_mix, wet_mix, room_size, dampping, width);
	reverb_effects.insert_last(rf1);
}
void destroy_all_reverb_effects() {
	for (uint j = 0; j < pools.length(); j++)
		pools[j].mixer.set_fx("$");
	reverb_effects.resize(0);
}
void initialize_pools() {
	pools = {
		@rvp,
		@mpool
	};
	foreach (sound_pool@ l: pools) {
		@l.mixer = mixer();
	}
}